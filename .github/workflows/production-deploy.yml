name: Production Deployment Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
        - prod
        - staging

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: document-portal
  PROD_CLUSTER: prod-document-portal-cluster
  PROD_SERVICE: prod-document-portal-service
  PROD_TASK_DEFINITION: prod-document-portal-task

jobs:
  # Security and Quality Checks
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '489356685327.dkr.ecr.us-east-1.amazonaws.com/document-portal:latest'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build and Test
  build-and-test:
    runs-on: ubuntu-latest
    needs: security-scan
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run tests
      run: |
        echo "Running application tests..."
        python -m pytest tests/ -v --cov=src --cov-report=xml
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

    - name: Build Docker image
      run: |
        echo "Building multi-platform Docker image..."
        docker buildx create --use --name multi-platform-builder
        docker buildx build --platform linux/amd64,linux/arm64 \
          -t 489356685327.dkr.ecr.us-east-1.amazonaws.com/document-portal:latest \
          -t 489356685327.dkr.ecr.us-east-1.amazonaws.com/document-portal:${{ github.sha }} \
          --push .

  # Deploy to Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Deploy to ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v2
      with:
        task-definition: .github/workflows/production-task-definition.json
        service: ${{ env.PROD_SERVICE }}
        cluster: ${{ env.PROD_CLUSTER }}
        wait-for-service-stability: true
        wait-for-minutes: 10

    - name: Health Check
      run: |
        echo "Waiting for service to be healthy..."
        sleep 60
        
        # Get ALB DNS name from CloudFormation
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name document-portal-production \
          --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
          --output text)
        
        echo "Testing ALB endpoint: $ALB_DNS"
        
        # Test health endpoint
        for i in {1..10}; do
          if curl -f -s "http://$ALB_DNS/health" > /dev/null; then
            echo "‚úÖ Health check passed!"
            break
          else
            echo "‚è≥ Attempt $i: Service not ready yet..."
            sleep 30
          fi
        done

    - name: Load Testing
      run: |
        echo "Running basic load test..."
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name document-portal-production \
          --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
          --output text)
        
        # Install hey for load testing
        wget https://github.com/rakyll/hey/releases/download/v0.1.4/hey_linux_amd64
        chmod +x hey_linux_amd64
        
        # Run load test
        ./hey_linux_amd64 -n 100 -c 10 "http://$ALB_DNS/health"
        
        echo "Load test completed!"

    - name: Functional Testing
      run: |
        echo "Running functional tests..."
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name document-portal-production \
          --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
          --output text)
        
        # Test main endpoints
        echo "Testing main application..."
        curl -f -s "http://$ALB_DNS/" > /dev/null && echo "‚úÖ Main page accessible"
        curl -f -s "http://$ALB_DNS/docs" > /dev/null && echo "‚úÖ API docs accessible"
        
        echo "Functional tests completed!"

  # Post-deployment verification
  verify-deployment:
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always()
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get deployment status
      run: |
        echo "=== PRODUCTION DEPLOYMENT STATUS ==="
        
        # Get ALB DNS name
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name document-portal-production \
          --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
          --output text)
        
        echo "üåê Load Balancer DNS: $ALB_DNS"
        
        # Check ECS service status
        aws ecs describe-services \
          --cluster ${{ env.PROD_CLUSTER }} \
          --services ${{ env.PROD_SERVICE }} \
          --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}' \
          --output table
        
        # Check CloudWatch metrics
        echo "üìä Service is now running on production infrastructure!"
        echo "üîó Production URL: http://$ALB_DNS"
        echo "üîó Health Check: http://$ALB_DNS/health"
        echo "üîó API Docs: http://$ALB_DNS/docs"
